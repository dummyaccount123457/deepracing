/* deepf1_gsoapC.cpp
   Generated by gSOAP 2.8.63 for gsoap_templates.h

gSOAP XML Web services tools
Copyright (C) 2000-2018, Robert van Engelen, Genivia Inc. All Rights Reserved.
The soapcpp2 tool and its generated software are released under the GPL.
This program is released under the GPL with the additional exemption that
compiling, linking, and/or using OpenSSL is allowed.
--------------------------------------------------------------------------------
A commercial use license is available from Genivia Inc., contact@genivia.com
--------------------------------------------------------------------------------
*/

#if defined(__BORLANDC__)
#pragma option push -w-8060
#pragma option push -w-8004
#endif

#include "deepf1_gsoapH.h"

namespace deepf1_gsoap {

SOAP_SOURCE_STAMP("@(#) deepf1_gsoapC.cpp ver 2.8.63 2018-02-23 19:05:58 GMT")


SOAP_FMAC3 void * SOAP_FMAC4 deepf1_gsoap_instantiate(struct soap *soap, int t, const char *type, const char *arrayType, size_t *n)
{	(void)type;
	switch (t)
	{
	case SOAP_TYPE_deepf1_gsoap_CarUDPData:
		return (void*)soap_instantiate_CarUDPData(soap, -1, type, arrayType, n);
	case SOAP_TYPE_deepf1_gsoap_UDPPacket:
		return (void*)soap_instantiate_UDPPacket(soap, -1, type, arrayType, n);
	case SOAP_TYPE_deepf1_gsoap_std__string:
		return (void*)soap_instantiate_std__string(soap, -1, type, arrayType, n);
	case SOAP_TYPE_deepf1_gsoap_ground_truth_sample:
		return (void*)soap_instantiate_ground_truth_sample(soap, -1, type, arrayType, n);
	}
	return NULL;
}

SOAP_FMAC3 int SOAP_FMAC4 deepf1_gsoap_fdelete(struct soap *soap, struct soap_clist *p)
{	(void)soap; /* appease -Wall -Werror */
	if (!p->ptr)
		return SOAP_OK;
	switch (p->type)
	{
	case SOAP_TYPE_deepf1_gsoap_CarUDPData:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<CarUDPData*>(p->ptr), CarUDPData);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<CarUDPData*>(p->ptr), CarUDPData);
		break;
	case SOAP_TYPE_deepf1_gsoap_UDPPacket:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<UDPPacket*>(p->ptr), UDPPacket);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<UDPPacket*>(p->ptr), UDPPacket);
		break;
	case SOAP_TYPE_deepf1_gsoap_std__string:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<std::string*>(p->ptr), std::string);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<std::string*>(p->ptr), std::string);
		break;
	case SOAP_TYPE_deepf1_gsoap_ground_truth_sample:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<ground_truth_sample*>(p->ptr), ground_truth_sample);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<ground_truth_sample*>(p->ptr), ground_truth_sample);
		break;
	default:
		return SOAP_ERR;
	}
	return SOAP_OK;
}

#ifdef WIN32
#pragma warning(push)
// do not warn on switch w/o cases
#pragma warning(disable:4065)
#endif
SOAP_FMAC3 int SOAP_FMAC4 deepf1_gsoap_fbase(int t, int b)
{	(void)t; (void)b; /* appease -Wall -Werror */
	return 0;
}
#ifdef WIN32
#pragma warning(pop)
#endif

#ifndef WITH_NOIDREF
#ifdef WIN32
#pragma warning(push)
// do not warn on switch w/o cases
#pragma warning(disable:4065)
#endif
SOAP_FMAC3 void SOAP_FMAC4 deepf1_gsoap_finsert(struct soap *soap, int t, int tt, void *p, size_t index, const void *q, void **x)
{
	(void)soap; (void)t; (void)p; (void)index; (void)q; (void)x; /* appease -Wall -Werror */
	switch (tt)
	{
	case SOAP_TYPE_deepf1_gsoap_CarUDPData:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy CarUDPData type=%d location=%p object=%p\n", t, p, q));
		*(CarUDPData*)p = *(CarUDPData*)q;
		break;
	case SOAP_TYPE_deepf1_gsoap_UDPPacket:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy UDPPacket type=%d location=%p object=%p\n", t, p, q));
		*(UDPPacket*)p = *(UDPPacket*)q;
		break;
	case SOAP_TYPE_deepf1_gsoap_std__string:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy std::string type=%d location=%p object=%p\n", t, p, q));
		*(std::string*)p = *(std::string*)q;
		break;
	case SOAP_TYPE_deepf1_gsoap_ground_truth_sample:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy ground_truth_sample type=%d location=%p object=%p\n", t, p, q));
		*(ground_truth_sample*)p = *(ground_truth_sample*)q;
		break;
	default:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Could not insert type=%d in %d\n", t, tt));
	}
}
#ifdef WIN32
#pragma warning(pop)
#endif
#endif

SOAP_FMAC3 int SOAP_FMAC4 soap_out_byte(struct soap *soap, const char *tag, int id, const char *a, const char *type)
{
	return soap_outbyte(soap, tag, id, a, type, SOAP_TYPE_deepf1_gsoap_byte);
}

SOAP_FMAC3 char * SOAP_FMAC4 soap_in_byte(struct soap *soap, const char *tag, char *a, const char *type)
{
	a = soap_inbyte(soap, tag, a, type, SOAP_TYPE_deepf1_gsoap_byte);
	return a;
}

SOAP_FMAC3 char * SOAP_FMAC4 soap_new_byte(struct soap *soap, int n)
{
	char *a = static_cast<char *>(soap_malloc(soap, (n = (n < 0 ? 1 : n)) * sizeof(char)));
	for (char *p = a; p && n--; ++p)
		soap_default_byte(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_byte(struct soap *soap, const char *a, const char *tag, const char *type)
{
	if (soap_out_byte(soap, tag ? tag : "byte", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 char * SOAP_FMAC4 soap_get_byte(struct soap *soap, char *p, const char *tag, const char *type)
{
	if ((p = soap_in_byte(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_LONG64(struct soap *soap, const char *tag, int id, const LONG64 *a, const char *type)
{
	return soap_outLONG64(soap, tag, id, a, type, SOAP_TYPE_deepf1_gsoap_LONG64);
}

SOAP_FMAC3 LONG64 * SOAP_FMAC4 soap_in_LONG64(struct soap *soap, const char *tag, LONG64 *a, const char *type)
{
	a = soap_inLONG64(soap, tag, a, type, SOAP_TYPE_deepf1_gsoap_LONG64);
	return a;
}

SOAP_FMAC3 LONG64 * SOAP_FMAC4 soap_new_LONG64(struct soap *soap, int n)
{
	LONG64 *a = static_cast<LONG64 *>(soap_malloc(soap, (n = (n < 0 ? 1 : n)) * sizeof(LONG64)));
	for (LONG64 *p = a; p && n--; ++p)
		soap_default_LONG64(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_LONG64(struct soap *soap, const LONG64 *a, const char *tag, const char *type)
{
	if (soap_out_LONG64(soap, tag ? tag : "long", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 LONG64 * SOAP_FMAC4 soap_get_LONG64(struct soap *soap, LONG64 *p, const char *tag, const char *type)
{
	if ((p = soap_in_LONG64(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_float(struct soap *soap, const char *tag, int id, const float *a, const char *type)
{
	return soap_outfloat(soap, tag, id, a, type, SOAP_TYPE_deepf1_gsoap_float);
}

SOAP_FMAC3 float * SOAP_FMAC4 soap_in_float(struct soap *soap, const char *tag, float *a, const char *type)
{
	a = soap_infloat(soap, tag, a, type, SOAP_TYPE_deepf1_gsoap_float);
	return a;
}

SOAP_FMAC3 float * SOAP_FMAC4 soap_new_float(struct soap *soap, int n)
{
	float *a = static_cast<float *>(soap_malloc(soap, (n = (n < 0 ? 1 : n)) * sizeof(float)));
	for (float *p = a; p && n--; ++p)
		soap_default_float(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_float(struct soap *soap, const float *a, const char *tag, const char *type)
{
	if (soap_out_float(soap, tag ? tag : "float", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 float * SOAP_FMAC4 soap_get_float(struct soap *soap, float *p, const char *tag, const char *type)
{
	if ((p = soap_in_float(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__string(struct soap *soap, const std::string *a)
{	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__string(struct soap *soap, const char *tag, int id, const std::string *s, const char *type)
{
	if ((soap->mode & SOAP_C_NILSTRING) && s->empty())
		return soap_element_null(soap, tag, id, type);
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, s, SOAP_TYPE_deepf1_gsoap_std__string), type) || soap_string_out(soap, s->c_str(), 0) || soap_element_end_out(soap, tag))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 std::string * SOAP_FMAC4 soap_in_std__string(struct soap *soap, const char *tag, std::string *s, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!s)
		s = soap_new_std__string(soap, -1);
	if (soap->null)
		if (s)
			s->erase();
	if (soap->body && *soap->href != '#')
	{	char *t;
		s = (std::string*)soap_id_enter(soap, soap->id, s, SOAP_TYPE_deepf1_gsoap_std__string, sizeof(std::string), soap->type, soap->arrayType, deepf1_gsoap_instantiate, deepf1_gsoap_fbase);
		if (s)
		{	if (!(t = soap_string_in(soap, 1, 0, -1, NULL)))
				return NULL;
			s->assign(t);
		}
	}
	else
		s = (std::string*)soap_id_forward(soap, soap->href, soap_id_enter(soap, soap->id, s, SOAP_TYPE_deepf1_gsoap_std__string, sizeof(std::string), soap->type, soap->arrayType, deepf1_gsoap_instantiate, deepf1_gsoap_fbase), 0, SOAP_TYPE_deepf1_gsoap_std__string, SOAP_TYPE_deepf1_gsoap_std__string, sizeof(std::string), 0, deepf1_gsoap_finsert, NULL);
	if (soap->body && soap_element_end_in(soap, tag))
		return NULL;
	return s;
}

SOAP_FMAC1 std::string * SOAP_FMAC2 soap_instantiate_std__string(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_std__string(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	std::string *p;
	size_t k = sizeof(std::string);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_deepf1_gsoap_std__string, n, deepf1_gsoap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, std::string);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, std::string, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated std::string location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_std__string(struct soap *soap, const std::string *a, const char *tag, const char *type)
{
	if (soap_out_std__string(soap, tag ? tag : "string", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 std::string * SOAP_FMAC4 soap_get_std__string(struct soap *soap, std::string *p, const char *tag, const char *type)
{
	if ((p = soap_in_std__string(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void ground_truth_sample::soap_default(struct soap *soap)
{
	(void)soap; /* appease -Wall -Werror */
	this->ground_truth_sample::sample.UDPPacket::soap_default(soap);
	soap_default_std__string(soap, &this->ground_truth_sample::image_file);
	soap_default_LONG64(soap, &this->ground_truth_sample::timestamp);
}

void ground_truth_sample::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_embedded(soap, &this->ground_truth_sample::sample, SOAP_TYPE_deepf1_gsoap_UDPPacket);
	this->ground_truth_sample::sample.soap_serialize(soap);
	soap_embedded(soap, &this->ground_truth_sample::image_file, SOAP_TYPE_deepf1_gsoap_std__string);
	soap_serialize_std__string(soap, &this->ground_truth_sample::image_file);
#endif
}

int ground_truth_sample::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ground_truth_sample(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ground_truth_sample(struct soap *soap, const char *tag, int id, const ground_truth_sample *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_deepf1_gsoap_ground_truth_sample), type))
		return soap->error;
	if ((a->ground_truth_sample::sample).soap_out(soap, "sample", -1, ""))
		return soap->error;
	if (soap_out_std__string(soap, "image-file", -1, &a->ground_truth_sample::image_file, ""))
		return soap->error;
	if (soap_out_LONG64(soap, "timestamp", -1, &a->ground_truth_sample::timestamp, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ground_truth_sample::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ground_truth_sample(soap, tag, this, type);
}

SOAP_FMAC3 ground_truth_sample * SOAP_FMAC4 soap_in_ground_truth_sample(struct soap *soap, const char *tag, ground_truth_sample *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ground_truth_sample *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_deepf1_gsoap_ground_truth_sample, sizeof(ground_truth_sample), soap->type, soap->arrayType, deepf1_gsoap_instantiate, deepf1_gsoap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_deepf1_gsoap_ground_truth_sample)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (ground_truth_sample *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_sample1 = 1;
	size_t soap_flag_image_file1 = 1;
	size_t soap_flag_timestamp1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_sample1 && soap->error == SOAP_TAG_MISMATCH)
			{	if ((a->ground_truth_sample::sample).soap_in(soap, "sample", "UDPPacket"))
				{	soap_flag_sample1--;
					continue;
				}
			}
			if (soap_flag_image_file1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_std__string(soap, "image-file", &a->ground_truth_sample::image_file, "xsd:string"))
				{	soap_flag_image_file1--;
					continue;
				}
			}
			if (soap_flag_timestamp1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_LONG64(soap, "timestamp", &a->ground_truth_sample::timestamp, "xsd:long"))
				{	soap_flag_timestamp1--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_sample1 > 0 || soap_flag_image_file1 > 0 || soap_flag_timestamp1 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (ground_truth_sample *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_deepf1_gsoap_ground_truth_sample, SOAP_TYPE_deepf1_gsoap_ground_truth_sample, sizeof(ground_truth_sample), 0, deepf1_gsoap_finsert, deepf1_gsoap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 ground_truth_sample * SOAP_FMAC2 soap_instantiate_ground_truth_sample(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ground_truth_sample(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	ground_truth_sample *p;
	size_t k = sizeof(ground_truth_sample);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_deepf1_gsoap_ground_truth_sample, n, deepf1_gsoap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, ground_truth_sample);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, ground_truth_sample, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated ground_truth_sample location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int ground_truth_sample::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_ground_truth_sample(soap, tag ? tag : "ground-truth-sample", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ground_truth_sample::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ground_truth_sample(soap, this, tag, type);
}

SOAP_FMAC3 ground_truth_sample * SOAP_FMAC4 soap_get_ground_truth_sample(struct soap *soap, ground_truth_sample *p, const char *tag, const char *type)
{
	if ((p = soap_in_ground_truth_sample(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void UDPPacket::soap_default(struct soap *soap)
{
	(void)soap; /* appease -Wall -Werror */
	soap_default_float(soap, &this->UDPPacket::m_time);
	soap_default_float(soap, &this->UDPPacket::m_lapTime);
	soap_default_float(soap, &this->UDPPacket::m_lapDistance);
	soap_default_float(soap, &this->UDPPacket::m_totalDistance);
	soap_default_float(soap, &this->UDPPacket::m_x);
	soap_default_float(soap, &this->UDPPacket::m_y);
	soap_default_float(soap, &this->UDPPacket::m_z);
	soap_default_float(soap, &this->UDPPacket::m_speed);
	soap_default_float(soap, &this->UDPPacket::m_xv);
	soap_default_float(soap, &this->UDPPacket::m_yv);
	soap_default_float(soap, &this->UDPPacket::m_zv);
	soap_default_float(soap, &this->UDPPacket::m_xr);
	soap_default_float(soap, &this->UDPPacket::m_yr);
	soap_default_float(soap, &this->UDPPacket::m_zr);
	soap_default_float(soap, &this->UDPPacket::m_xd);
	soap_default_float(soap, &this->UDPPacket::m_yd);
	soap_default_float(soap, &this->UDPPacket::m_zd);
	soap_default_Array4Offloat(soap, this->UDPPacket::m_susp_pos);
	soap_default_Array4Offloat(soap, this->UDPPacket::m_susp_vel);
	soap_default_Array4Offloat(soap, this->UDPPacket::m_wheel_speed);
	soap_default_float(soap, &this->UDPPacket::m_throttle);
	soap_default_float(soap, &this->UDPPacket::m_steer);
	soap_default_float(soap, &this->UDPPacket::m_brake);
	soap_default_float(soap, &this->UDPPacket::m_clutch);
	soap_default_float(soap, &this->UDPPacket::m_gear);
	soap_default_float(soap, &this->UDPPacket::m_gforce_lat);
	soap_default_float(soap, &this->UDPPacket::m_gforce_lon);
	soap_default_float(soap, &this->UDPPacket::m_lap);
	soap_default_float(soap, &this->UDPPacket::m_engineRate);
	soap_default_float(soap, &this->UDPPacket::m_sli_pro_native_support);
	soap_default_float(soap, &this->UDPPacket::m_car_position);
	soap_default_float(soap, &this->UDPPacket::m_kers_level);
	soap_default_float(soap, &this->UDPPacket::m_kers_max_level);
	soap_default_float(soap, &this->UDPPacket::m_drs);
	soap_default_float(soap, &this->UDPPacket::m_traction_control);
	soap_default_float(soap, &this->UDPPacket::m_anti_lock_brakes);
	soap_default_float(soap, &this->UDPPacket::m_fuel_in_tank);
	soap_default_float(soap, &this->UDPPacket::m_fuel_capacity);
	soap_default_float(soap, &this->UDPPacket::m_in_pits);
	soap_default_float(soap, &this->UDPPacket::m_sector);
	soap_default_float(soap, &this->UDPPacket::m_sector1_time);
	soap_default_float(soap, &this->UDPPacket::m_sector2_time);
	soap_default_Array4Offloat(soap, this->UDPPacket::m_brakes_temp);
	soap_default_Array4Offloat(soap, this->UDPPacket::m_tyres_pressure);
	soap_default_float(soap, &this->UDPPacket::m_team_info);
	soap_default_float(soap, &this->UDPPacket::m_total_laps);
	soap_default_float(soap, &this->UDPPacket::m_track_size);
	soap_default_float(soap, &this->UDPPacket::m_last_lap_time);
	soap_default_float(soap, &this->UDPPacket::m_max_rpm);
	soap_default_float(soap, &this->UDPPacket::m_idle_rpm);
	soap_default_float(soap, &this->UDPPacket::m_max_gears);
	soap_default_float(soap, &this->UDPPacket::m_sessionType);
	soap_default_float(soap, &this->UDPPacket::m_drsAllowed);
	soap_default_float(soap, &this->UDPPacket::m_track_number);
	soap_default_float(soap, &this->UDPPacket::m_vehicleFIAFlags);
	soap_default_float(soap, &this->UDPPacket::m_era);
	soap_default_float(soap, &this->UDPPacket::m_engine_temperature);
	soap_default_float(soap, &this->UDPPacket::m_gforce_vert);
	soap_default_float(soap, &this->UDPPacket::m_ang_vel_x);
	soap_default_float(soap, &this->UDPPacket::m_ang_vel_y);
	soap_default_float(soap, &this->UDPPacket::m_ang_vel_z);
	soap_default_Array4Ofbyte(soap, this->UDPPacket::m_tyres_temperature);
	soap_default_Array4Ofbyte(soap, this->UDPPacket::m_tyres_wear);
	soap_default_byte(soap, &this->UDPPacket::m_tyre_compound);
	soap_default_byte(soap, &this->UDPPacket::m_front_brake_bias);
	soap_default_byte(soap, &this->UDPPacket::m_fuel_mix);
	soap_default_byte(soap, &this->UDPPacket::m_currentLapInvalid);
	soap_default_Array4Ofbyte(soap, this->UDPPacket::m_tyres_damage);
	soap_default_byte(soap, &this->UDPPacket::m_front_left_wing_damage);
	soap_default_byte(soap, &this->UDPPacket::m_front_right_wing_damage);
	soap_default_byte(soap, &this->UDPPacket::m_rear_wing_damage);
	soap_default_byte(soap, &this->UDPPacket::m_engine_damage);
	soap_default_byte(soap, &this->UDPPacket::m_gear_box_damage);
	soap_default_byte(soap, &this->UDPPacket::m_exhaust_damage);
	soap_default_byte(soap, &this->UDPPacket::m_pit_limiter_status);
	soap_default_byte(soap, &this->UDPPacket::m_pit_speed_limit);
	soap_default_float(soap, &this->UDPPacket::m_session_time_left);
	soap_default_byte(soap, &this->UDPPacket::m_rev_lights_percent);
	soap_default_byte(soap, &this->UDPPacket::m_is_spectating);
	soap_default_byte(soap, &this->UDPPacket::m_spectator_car_index);
	soap_default_byte(soap, &this->UDPPacket::m_num_cars);
	soap_default_byte(soap, &this->UDPPacket::m_player_car_index);
	soap_default_Array20OfCarUDPData(soap, this->UDPPacket::m_car_data);
	soap_default_float(soap, &this->UDPPacket::m_yaw);
	soap_default_float(soap, &this->UDPPacket::m_pitch);
	soap_default_float(soap, &this->UDPPacket::m_roll);
	soap_default_float(soap, &this->UDPPacket::m_x_local_velocity);
	soap_default_float(soap, &this->UDPPacket::m_y_local_velocity);
	soap_default_float(soap, &this->UDPPacket::m_z_local_velocity);
	soap_default_Array4Offloat(soap, this->UDPPacket::m_susp_acceleration);
	soap_default_float(soap, &this->UDPPacket::m_ang_acc_x);
	soap_default_float(soap, &this->UDPPacket::m_ang_acc_y);
	soap_default_float(soap, &this->UDPPacket::m_ang_acc_z);
}

void UDPPacket::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_Array4Offloat(soap, this->UDPPacket::m_susp_pos);
	soap_serialize_Array4Offloat(soap, this->UDPPacket::m_susp_vel);
	soap_serialize_Array4Offloat(soap, this->UDPPacket::m_wheel_speed);
	soap_serialize_Array4Offloat(soap, this->UDPPacket::m_brakes_temp);
	soap_serialize_Array4Offloat(soap, this->UDPPacket::m_tyres_pressure);
	soap_serialize_Array4Ofbyte(soap, this->UDPPacket::m_tyres_temperature);
	soap_serialize_Array4Ofbyte(soap, this->UDPPacket::m_tyres_wear);
	soap_embedded(soap, &this->UDPPacket::m_tyre_compound, SOAP_TYPE_deepf1_gsoap_byte);
	soap_embedded(soap, &this->UDPPacket::m_front_brake_bias, SOAP_TYPE_deepf1_gsoap_byte);
	soap_embedded(soap, &this->UDPPacket::m_fuel_mix, SOAP_TYPE_deepf1_gsoap_byte);
	soap_embedded(soap, &this->UDPPacket::m_currentLapInvalid, SOAP_TYPE_deepf1_gsoap_byte);
	soap_serialize_Array4Ofbyte(soap, this->UDPPacket::m_tyres_damage);
	soap_embedded(soap, &this->UDPPacket::m_front_left_wing_damage, SOAP_TYPE_deepf1_gsoap_byte);
	soap_embedded(soap, &this->UDPPacket::m_front_right_wing_damage, SOAP_TYPE_deepf1_gsoap_byte);
	soap_embedded(soap, &this->UDPPacket::m_rear_wing_damage, SOAP_TYPE_deepf1_gsoap_byte);
	soap_embedded(soap, &this->UDPPacket::m_engine_damage, SOAP_TYPE_deepf1_gsoap_byte);
	soap_embedded(soap, &this->UDPPacket::m_gear_box_damage, SOAP_TYPE_deepf1_gsoap_byte);
	soap_embedded(soap, &this->UDPPacket::m_exhaust_damage, SOAP_TYPE_deepf1_gsoap_byte);
	soap_embedded(soap, &this->UDPPacket::m_pit_limiter_status, SOAP_TYPE_deepf1_gsoap_byte);
	soap_embedded(soap, &this->UDPPacket::m_pit_speed_limit, SOAP_TYPE_deepf1_gsoap_byte);
	soap_embedded(soap, &this->UDPPacket::m_rev_lights_percent, SOAP_TYPE_deepf1_gsoap_byte);
	soap_embedded(soap, &this->UDPPacket::m_is_spectating, SOAP_TYPE_deepf1_gsoap_byte);
	soap_embedded(soap, &this->UDPPacket::m_spectator_car_index, SOAP_TYPE_deepf1_gsoap_byte);
	soap_embedded(soap, &this->UDPPacket::m_num_cars, SOAP_TYPE_deepf1_gsoap_byte);
	soap_embedded(soap, &this->UDPPacket::m_player_car_index, SOAP_TYPE_deepf1_gsoap_byte);
	soap_serialize_Array20OfCarUDPData(soap, this->UDPPacket::m_car_data);
	soap_serialize_Array4Offloat(soap, this->UDPPacket::m_susp_acceleration);
#endif
}

int UDPPacket::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_UDPPacket(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_UDPPacket(struct soap *soap, const char *tag, int id, const UDPPacket *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_deepf1_gsoap_UDPPacket), type))
		return soap->error;
	if (soap_out_float(soap, "m-time", -1, &a->UDPPacket::m_time, ""))
		return soap->error;
	if (soap_out_float(soap, "m-lapTime", -1, &a->UDPPacket::m_lapTime, ""))
		return soap->error;
	if (soap_out_float(soap, "m-lapDistance", -1, &a->UDPPacket::m_lapDistance, ""))
		return soap->error;
	if (soap_out_float(soap, "m-totalDistance", -1, &a->UDPPacket::m_totalDistance, ""))
		return soap->error;
	if (soap_out_float(soap, "m-x", -1, &a->UDPPacket::m_x, ""))
		return soap->error;
	if (soap_out_float(soap, "m-y", -1, &a->UDPPacket::m_y, ""))
		return soap->error;
	if (soap_out_float(soap, "m-z", -1, &a->UDPPacket::m_z, ""))
		return soap->error;
	if (soap_out_float(soap, "m-speed", -1, &a->UDPPacket::m_speed, ""))
		return soap->error;
	if (soap_out_float(soap, "m-xv", -1, &a->UDPPacket::m_xv, ""))
		return soap->error;
	if (soap_out_float(soap, "m-yv", -1, &a->UDPPacket::m_yv, ""))
		return soap->error;
	if (soap_out_float(soap, "m-zv", -1, &a->UDPPacket::m_zv, ""))
		return soap->error;
	if (soap_out_float(soap, "m-xr", -1, &a->UDPPacket::m_xr, ""))
		return soap->error;
	if (soap_out_float(soap, "m-yr", -1, &a->UDPPacket::m_yr, ""))
		return soap->error;
	if (soap_out_float(soap, "m-zr", -1, &a->UDPPacket::m_zr, ""))
		return soap->error;
	if (soap_out_float(soap, "m-xd", -1, &a->UDPPacket::m_xd, ""))
		return soap->error;
	if (soap_out_float(soap, "m-yd", -1, &a->UDPPacket::m_yd, ""))
		return soap->error;
	if (soap_out_float(soap, "m-zd", -1, &a->UDPPacket::m_zd, ""))
		return soap->error;
	if (soap_out_Array4Offloat(soap, "m-susp-pos", -1, a->UDPPacket::m_susp_pos, ""))
		return soap->error;
	if (soap_out_Array4Offloat(soap, "m-susp-vel", -1, a->UDPPacket::m_susp_vel, ""))
		return soap->error;
	if (soap_out_Array4Offloat(soap, "m-wheel-speed", -1, a->UDPPacket::m_wheel_speed, ""))
		return soap->error;
	if (soap_out_float(soap, "m-throttle", -1, &a->UDPPacket::m_throttle, ""))
		return soap->error;
	if (soap_out_float(soap, "m-steer", -1, &a->UDPPacket::m_steer, ""))
		return soap->error;
	if (soap_out_float(soap, "m-brake", -1, &a->UDPPacket::m_brake, ""))
		return soap->error;
	if (soap_out_float(soap, "m-clutch", -1, &a->UDPPacket::m_clutch, ""))
		return soap->error;
	if (soap_out_float(soap, "m-gear", -1, &a->UDPPacket::m_gear, ""))
		return soap->error;
	if (soap_out_float(soap, "m-gforce-lat", -1, &a->UDPPacket::m_gforce_lat, ""))
		return soap->error;
	if (soap_out_float(soap, "m-gforce-lon", -1, &a->UDPPacket::m_gforce_lon, ""))
		return soap->error;
	if (soap_out_float(soap, "m-lap", -1, &a->UDPPacket::m_lap, ""))
		return soap->error;
	if (soap_out_float(soap, "m-engineRate", -1, &a->UDPPacket::m_engineRate, ""))
		return soap->error;
	if (soap_out_float(soap, "m-sli-pro-native-support", -1, &a->UDPPacket::m_sli_pro_native_support, ""))
		return soap->error;
	if (soap_out_float(soap, "m-car-position", -1, &a->UDPPacket::m_car_position, ""))
		return soap->error;
	if (soap_out_float(soap, "m-kers-level", -1, &a->UDPPacket::m_kers_level, ""))
		return soap->error;
	if (soap_out_float(soap, "m-kers-max-level", -1, &a->UDPPacket::m_kers_max_level, ""))
		return soap->error;
	if (soap_out_float(soap, "m-drs", -1, &a->UDPPacket::m_drs, ""))
		return soap->error;
	if (soap_out_float(soap, "m-traction-control", -1, &a->UDPPacket::m_traction_control, ""))
		return soap->error;
	if (soap_out_float(soap, "m-anti-lock-brakes", -1, &a->UDPPacket::m_anti_lock_brakes, ""))
		return soap->error;
	if (soap_out_float(soap, "m-fuel-in-tank", -1, &a->UDPPacket::m_fuel_in_tank, ""))
		return soap->error;
	if (soap_out_float(soap, "m-fuel-capacity", -1, &a->UDPPacket::m_fuel_capacity, ""))
		return soap->error;
	if (soap_out_float(soap, "m-in-pits", -1, &a->UDPPacket::m_in_pits, ""))
		return soap->error;
	if (soap_out_float(soap, "m-sector", -1, &a->UDPPacket::m_sector, ""))
		return soap->error;
	if (soap_out_float(soap, "m-sector1-time", -1, &a->UDPPacket::m_sector1_time, ""))
		return soap->error;
	if (soap_out_float(soap, "m-sector2-time", -1, &a->UDPPacket::m_sector2_time, ""))
		return soap->error;
	if (soap_out_Array4Offloat(soap, "m-brakes-temp", -1, a->UDPPacket::m_brakes_temp, ""))
		return soap->error;
	if (soap_out_Array4Offloat(soap, "m-tyres-pressure", -1, a->UDPPacket::m_tyres_pressure, ""))
		return soap->error;
	if (soap_out_float(soap, "m-team-info", -1, &a->UDPPacket::m_team_info, ""))
		return soap->error;
	if (soap_out_float(soap, "m-total-laps", -1, &a->UDPPacket::m_total_laps, ""))
		return soap->error;
	if (soap_out_float(soap, "m-track-size", -1, &a->UDPPacket::m_track_size, ""))
		return soap->error;
	if (soap_out_float(soap, "m-last-lap-time", -1, &a->UDPPacket::m_last_lap_time, ""))
		return soap->error;
	if (soap_out_float(soap, "m-max-rpm", -1, &a->UDPPacket::m_max_rpm, ""))
		return soap->error;
	if (soap_out_float(soap, "m-idle-rpm", -1, &a->UDPPacket::m_idle_rpm, ""))
		return soap->error;
	if (soap_out_float(soap, "m-max-gears", -1, &a->UDPPacket::m_max_gears, ""))
		return soap->error;
	if (soap_out_float(soap, "m-sessionType", -1, &a->UDPPacket::m_sessionType, ""))
		return soap->error;
	if (soap_out_float(soap, "m-drsAllowed", -1, &a->UDPPacket::m_drsAllowed, ""))
		return soap->error;
	if (soap_out_float(soap, "m-track-number", -1, &a->UDPPacket::m_track_number, ""))
		return soap->error;
	if (soap_out_float(soap, "m-vehicleFIAFlags", -1, &a->UDPPacket::m_vehicleFIAFlags, ""))
		return soap->error;
	if (soap_out_float(soap, "m-era", -1, &a->UDPPacket::m_era, ""))
		return soap->error;
	if (soap_out_float(soap, "m-engine-temperature", -1, &a->UDPPacket::m_engine_temperature, ""))
		return soap->error;
	if (soap_out_float(soap, "m-gforce-vert", -1, &a->UDPPacket::m_gforce_vert, ""))
		return soap->error;
	if (soap_out_float(soap, "m-ang-vel-x", -1, &a->UDPPacket::m_ang_vel_x, ""))
		return soap->error;
	if (soap_out_float(soap, "m-ang-vel-y", -1, &a->UDPPacket::m_ang_vel_y, ""))
		return soap->error;
	if (soap_out_float(soap, "m-ang-vel-z", -1, &a->UDPPacket::m_ang_vel_z, ""))
		return soap->error;
	if (soap_out_Array4Ofbyte(soap, "m-tyres-temperature", -1, a->UDPPacket::m_tyres_temperature, ""))
		return soap->error;
	if (soap_out_Array4Ofbyte(soap, "m-tyres-wear", -1, a->UDPPacket::m_tyres_wear, ""))
		return soap->error;
	if (soap_out_byte(soap, "m-tyre-compound", -1, &a->UDPPacket::m_tyre_compound, ""))
		return soap->error;
	if (soap_out_byte(soap, "m-front-brake-bias", -1, &a->UDPPacket::m_front_brake_bias, ""))
		return soap->error;
	if (soap_out_byte(soap, "m-fuel-mix", -1, &a->UDPPacket::m_fuel_mix, ""))
		return soap->error;
	if (soap_out_byte(soap, "m-currentLapInvalid", -1, &a->UDPPacket::m_currentLapInvalid, ""))
		return soap->error;
	if (soap_out_Array4Ofbyte(soap, "m-tyres-damage", -1, a->UDPPacket::m_tyres_damage, ""))
		return soap->error;
	if (soap_out_byte(soap, "m-front-left-wing-damage", -1, &a->UDPPacket::m_front_left_wing_damage, ""))
		return soap->error;
	if (soap_out_byte(soap, "m-front-right-wing-damage", -1, &a->UDPPacket::m_front_right_wing_damage, ""))
		return soap->error;
	if (soap_out_byte(soap, "m-rear-wing-damage", -1, &a->UDPPacket::m_rear_wing_damage, ""))
		return soap->error;
	if (soap_out_byte(soap, "m-engine-damage", -1, &a->UDPPacket::m_engine_damage, ""))
		return soap->error;
	if (soap_out_byte(soap, "m-gear-box-damage", -1, &a->UDPPacket::m_gear_box_damage, ""))
		return soap->error;
	if (soap_out_byte(soap, "m-exhaust-damage", -1, &a->UDPPacket::m_exhaust_damage, ""))
		return soap->error;
	if (soap_out_byte(soap, "m-pit-limiter-status", -1, &a->UDPPacket::m_pit_limiter_status, ""))
		return soap->error;
	if (soap_out_byte(soap, "m-pit-speed-limit", -1, &a->UDPPacket::m_pit_speed_limit, ""))
		return soap->error;
	if (soap_out_float(soap, "m-session-time-left", -1, &a->UDPPacket::m_session_time_left, ""))
		return soap->error;
	if (soap_out_byte(soap, "m-rev-lights-percent", -1, &a->UDPPacket::m_rev_lights_percent, ""))
		return soap->error;
	if (soap_out_byte(soap, "m-is-spectating", -1, &a->UDPPacket::m_is_spectating, ""))
		return soap->error;
	if (soap_out_byte(soap, "m-spectator-car-index", -1, &a->UDPPacket::m_spectator_car_index, ""))
		return soap->error;
	if (soap_out_byte(soap, "m-num-cars", -1, &a->UDPPacket::m_num_cars, ""))
		return soap->error;
	if (soap_out_byte(soap, "m-player-car-index", -1, &a->UDPPacket::m_player_car_index, ""))
		return soap->error;
	if (soap_out_Array20OfCarUDPData(soap, "m-car-data", -1, a->UDPPacket::m_car_data, ""))
		return soap->error;
	if (soap_out_float(soap, "m-yaw", -1, &a->UDPPacket::m_yaw, ""))
		return soap->error;
	if (soap_out_float(soap, "m-pitch", -1, &a->UDPPacket::m_pitch, ""))
		return soap->error;
	if (soap_out_float(soap, "m-roll", -1, &a->UDPPacket::m_roll, ""))
		return soap->error;
	if (soap_out_float(soap, "m-x-local-velocity", -1, &a->UDPPacket::m_x_local_velocity, ""))
		return soap->error;
	if (soap_out_float(soap, "m-y-local-velocity", -1, &a->UDPPacket::m_y_local_velocity, ""))
		return soap->error;
	if (soap_out_float(soap, "m-z-local-velocity", -1, &a->UDPPacket::m_z_local_velocity, ""))
		return soap->error;
	if (soap_out_Array4Offloat(soap, "m-susp-acceleration", -1, a->UDPPacket::m_susp_acceleration, ""))
		return soap->error;
	if (soap_out_float(soap, "m-ang-acc-x", -1, &a->UDPPacket::m_ang_acc_x, ""))
		return soap->error;
	if (soap_out_float(soap, "m-ang-acc-y", -1, &a->UDPPacket::m_ang_acc_y, ""))
		return soap->error;
	if (soap_out_float(soap, "m-ang-acc-z", -1, &a->UDPPacket::m_ang_acc_z, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *UDPPacket::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_UDPPacket(soap, tag, this, type);
}

SOAP_FMAC3 UDPPacket * SOAP_FMAC4 soap_in_UDPPacket(struct soap *soap, const char *tag, UDPPacket *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (UDPPacket *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_deepf1_gsoap_UDPPacket, sizeof(UDPPacket), soap->type, soap->arrayType, deepf1_gsoap_instantiate, deepf1_gsoap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_deepf1_gsoap_UDPPacket)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (UDPPacket *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_m_time1 = 1;
	size_t soap_flag_m_lapTime1 = 1;
	size_t soap_flag_m_lapDistance1 = 1;
	size_t soap_flag_m_totalDistance1 = 1;
	size_t soap_flag_m_x1 = 1;
	size_t soap_flag_m_y1 = 1;
	size_t soap_flag_m_z1 = 1;
	size_t soap_flag_m_speed1 = 1;
	size_t soap_flag_m_xv1 = 1;
	size_t soap_flag_m_yv1 = 1;
	size_t soap_flag_m_zv1 = 1;
	size_t soap_flag_m_xr1 = 1;
	size_t soap_flag_m_yr1 = 1;
	size_t soap_flag_m_zr1 = 1;
	size_t soap_flag_m_xd1 = 1;
	size_t soap_flag_m_yd1 = 1;
	size_t soap_flag_m_zd1 = 1;
	size_t soap_flag_m_susp_pos1 = 1;
	size_t soap_flag_m_susp_vel1 = 1;
	size_t soap_flag_m_wheel_speed1 = 1;
	size_t soap_flag_m_throttle1 = 1;
	size_t soap_flag_m_steer1 = 1;
	size_t soap_flag_m_brake1 = 1;
	size_t soap_flag_m_clutch1 = 1;
	size_t soap_flag_m_gear1 = 1;
	size_t soap_flag_m_gforce_lat1 = 1;
	size_t soap_flag_m_gforce_lon1 = 1;
	size_t soap_flag_m_lap1 = 1;
	size_t soap_flag_m_engineRate1 = 1;
	size_t soap_flag_m_sli_pro_native_support1 = 1;
	size_t soap_flag_m_car_position1 = 1;
	size_t soap_flag_m_kers_level1 = 1;
	size_t soap_flag_m_kers_max_level1 = 1;
	size_t soap_flag_m_drs1 = 1;
	size_t soap_flag_m_traction_control1 = 1;
	size_t soap_flag_m_anti_lock_brakes1 = 1;
	size_t soap_flag_m_fuel_in_tank1 = 1;
	size_t soap_flag_m_fuel_capacity1 = 1;
	size_t soap_flag_m_in_pits1 = 1;
	size_t soap_flag_m_sector1 = 1;
	size_t soap_flag_m_sector1_time1 = 1;
	size_t soap_flag_m_sector2_time1 = 1;
	size_t soap_flag_m_brakes_temp1 = 1;
	size_t soap_flag_m_tyres_pressure1 = 1;
	size_t soap_flag_m_team_info1 = 1;
	size_t soap_flag_m_total_laps1 = 1;
	size_t soap_flag_m_track_size1 = 1;
	size_t soap_flag_m_last_lap_time1 = 1;
	size_t soap_flag_m_max_rpm1 = 1;
	size_t soap_flag_m_idle_rpm1 = 1;
	size_t soap_flag_m_max_gears1 = 1;
	size_t soap_flag_m_sessionType1 = 1;
	size_t soap_flag_m_drsAllowed1 = 1;
	size_t soap_flag_m_track_number1 = 1;
	size_t soap_flag_m_vehicleFIAFlags1 = 1;
	size_t soap_flag_m_era1 = 1;
	size_t soap_flag_m_engine_temperature1 = 1;
	size_t soap_flag_m_gforce_vert1 = 1;
	size_t soap_flag_m_ang_vel_x1 = 1;
	size_t soap_flag_m_ang_vel_y1 = 1;
	size_t soap_flag_m_ang_vel_z1 = 1;
	size_t soap_flag_m_tyres_temperature1 = 1;
	size_t soap_flag_m_tyres_wear1 = 1;
	size_t soap_flag_m_tyre_compound1 = 1;
	size_t soap_flag_m_front_brake_bias1 = 1;
	size_t soap_flag_m_fuel_mix1 = 1;
	size_t soap_flag_m_currentLapInvalid1 = 1;
	size_t soap_flag_m_tyres_damage1 = 1;
	size_t soap_flag_m_front_left_wing_damage1 = 1;
	size_t soap_flag_m_front_right_wing_damage1 = 1;
	size_t soap_flag_m_rear_wing_damage1 = 1;
	size_t soap_flag_m_engine_damage1 = 1;
	size_t soap_flag_m_gear_box_damage1 = 1;
	size_t soap_flag_m_exhaust_damage1 = 1;
	size_t soap_flag_m_pit_limiter_status1 = 1;
	size_t soap_flag_m_pit_speed_limit1 = 1;
	size_t soap_flag_m_session_time_left1 = 1;
	size_t soap_flag_m_rev_lights_percent1 = 1;
	size_t soap_flag_m_is_spectating1 = 1;
	size_t soap_flag_m_spectator_car_index1 = 1;
	size_t soap_flag_m_num_cars1 = 1;
	size_t soap_flag_m_player_car_index1 = 1;
	size_t soap_flag_m_car_data1 = 1;
	size_t soap_flag_m_yaw1 = 1;
	size_t soap_flag_m_pitch1 = 1;
	size_t soap_flag_m_roll1 = 1;
	size_t soap_flag_m_x_local_velocity1 = 1;
	size_t soap_flag_m_y_local_velocity1 = 1;
	size_t soap_flag_m_z_local_velocity1 = 1;
	size_t soap_flag_m_susp_acceleration1 = 1;
	size_t soap_flag_m_ang_acc_x1 = 1;
	size_t soap_flag_m_ang_acc_y1 = 1;
	size_t soap_flag_m_ang_acc_z1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_m_time1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_float(soap, "m-time", &a->UDPPacket::m_time, "xsd:float"))
				{	soap_flag_m_time1--;
					continue;
				}
			}
			if (soap_flag_m_lapTime1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_float(soap, "m-lapTime", &a->UDPPacket::m_lapTime, "xsd:float"))
				{	soap_flag_m_lapTime1--;
					continue;
				}
			}
			if (soap_flag_m_lapDistance1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_float(soap, "m-lapDistance", &a->UDPPacket::m_lapDistance, "xsd:float"))
				{	soap_flag_m_lapDistance1--;
					continue;
				}
			}
			if (soap_flag_m_totalDistance1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_float(soap, "m-totalDistance", &a->UDPPacket::m_totalDistance, "xsd:float"))
				{	soap_flag_m_totalDistance1--;
					continue;
				}
			}
			if (soap_flag_m_x1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_float(soap, "m-x", &a->UDPPacket::m_x, "xsd:float"))
				{	soap_flag_m_x1--;
					continue;
				}
			}
			if (soap_flag_m_y1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_float(soap, "m-y", &a->UDPPacket::m_y, "xsd:float"))
				{	soap_flag_m_y1--;
					continue;
				}
			}
			if (soap_flag_m_z1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_float(soap, "m-z", &a->UDPPacket::m_z, "xsd:float"))
				{	soap_flag_m_z1--;
					continue;
				}
			}
			if (soap_flag_m_speed1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_float(soap, "m-speed", &a->UDPPacket::m_speed, "xsd:float"))
				{	soap_flag_m_speed1--;
					continue;
				}
			}
			if (soap_flag_m_xv1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_float(soap, "m-xv", &a->UDPPacket::m_xv, "xsd:float"))
				{	soap_flag_m_xv1--;
					continue;
				}
			}
			if (soap_flag_m_yv1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_float(soap, "m-yv", &a->UDPPacket::m_yv, "xsd:float"))
				{	soap_flag_m_yv1--;
					continue;
				}
			}
			if (soap_flag_m_zv1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_float(soap, "m-zv", &a->UDPPacket::m_zv, "xsd:float"))
				{	soap_flag_m_zv1--;
					continue;
				}
			}
			if (soap_flag_m_xr1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_float(soap, "m-xr", &a->UDPPacket::m_xr, "xsd:float"))
				{	soap_flag_m_xr1--;
					continue;
				}
			}
			if (soap_flag_m_yr1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_float(soap, "m-yr", &a->UDPPacket::m_yr, "xsd:float"))
				{	soap_flag_m_yr1--;
					continue;
				}
			}
			if (soap_flag_m_zr1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_float(soap, "m-zr", &a->UDPPacket::m_zr, "xsd:float"))
				{	soap_flag_m_zr1--;
					continue;
				}
			}
			if (soap_flag_m_xd1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_float(soap, "m-xd", &a->UDPPacket::m_xd, "xsd:float"))
				{	soap_flag_m_xd1--;
					continue;
				}
			}
			if (soap_flag_m_yd1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_float(soap, "m-yd", &a->UDPPacket::m_yd, "xsd:float"))
				{	soap_flag_m_yd1--;
					continue;
				}
			}
			if (soap_flag_m_zd1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_float(soap, "m-zd", &a->UDPPacket::m_zd, "xsd:float"))
				{	soap_flag_m_zd1--;
					continue;
				}
			}
			if (soap_flag_m_susp_pos1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_Array4Offloat(soap, "m-susp-pos", a->UDPPacket::m_susp_pos, "xsd:float"))
				{	soap_flag_m_susp_pos1--;
					continue;
				}
			}
			if (soap_flag_m_susp_vel1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_Array4Offloat(soap, "m-susp-vel", a->UDPPacket::m_susp_vel, "xsd:float"))
				{	soap_flag_m_susp_vel1--;
					continue;
				}
			}
			if (soap_flag_m_wheel_speed1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_Array4Offloat(soap, "m-wheel-speed", a->UDPPacket::m_wheel_speed, "xsd:float"))
				{	soap_flag_m_wheel_speed1--;
					continue;
				}
			}
			if (soap_flag_m_throttle1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_float(soap, "m-throttle", &a->UDPPacket::m_throttle, "xsd:float"))
				{	soap_flag_m_throttle1--;
					continue;
				}
			}
			if (soap_flag_m_steer1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_float(soap, "m-steer", &a->UDPPacket::m_steer, "xsd:float"))
				{	soap_flag_m_steer1--;
					continue;
				}
			}
			if (soap_flag_m_brake1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_float(soap, "m-brake", &a->UDPPacket::m_brake, "xsd:float"))
				{	soap_flag_m_brake1--;
					continue;
				}
			}
			if (soap_flag_m_clutch1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_float(soap, "m-clutch", &a->UDPPacket::m_clutch, "xsd:float"))
				{	soap_flag_m_clutch1--;
					continue;
				}
			}
			if (soap_flag_m_gear1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_float(soap, "m-gear", &a->UDPPacket::m_gear, "xsd:float"))
				{	soap_flag_m_gear1--;
					continue;
				}
			}
			if (soap_flag_m_gforce_lat1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_float(soap, "m-gforce-lat", &a->UDPPacket::m_gforce_lat, "xsd:float"))
				{	soap_flag_m_gforce_lat1--;
					continue;
				}
			}
			if (soap_flag_m_gforce_lon1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_float(soap, "m-gforce-lon", &a->UDPPacket::m_gforce_lon, "xsd:float"))
				{	soap_flag_m_gforce_lon1--;
					continue;
				}
			}
			if (soap_flag_m_lap1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_float(soap, "m-lap", &a->UDPPacket::m_lap, "xsd:float"))
				{	soap_flag_m_lap1--;
					continue;
				}
			}
			if (soap_flag_m_engineRate1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_float(soap, "m-engineRate", &a->UDPPacket::m_engineRate, "xsd:float"))
				{	soap_flag_m_engineRate1--;
					continue;
				}
			}
			if (soap_flag_m_sli_pro_native_support1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_float(soap, "m-sli-pro-native-support", &a->UDPPacket::m_sli_pro_native_support, "xsd:float"))
				{	soap_flag_m_sli_pro_native_support1--;
					continue;
				}
			}
			if (soap_flag_m_car_position1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_float(soap, "m-car-position", &a->UDPPacket::m_car_position, "xsd:float"))
				{	soap_flag_m_car_position1--;
					continue;
				}
			}
			if (soap_flag_m_kers_level1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_float(soap, "m-kers-level", &a->UDPPacket::m_kers_level, "xsd:float"))
				{	soap_flag_m_kers_level1--;
					continue;
				}
			}
			if (soap_flag_m_kers_max_level1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_float(soap, "m-kers-max-level", &a->UDPPacket::m_kers_max_level, "xsd:float"))
				{	soap_flag_m_kers_max_level1--;
					continue;
				}
			}
			if (soap_flag_m_drs1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_float(soap, "m-drs", &a->UDPPacket::m_drs, "xsd:float"))
				{	soap_flag_m_drs1--;
					continue;
				}
			}
			if (soap_flag_m_traction_control1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_float(soap, "m-traction-control", &a->UDPPacket::m_traction_control, "xsd:float"))
				{	soap_flag_m_traction_control1--;
					continue;
				}
			}
			if (soap_flag_m_anti_lock_brakes1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_float(soap, "m-anti-lock-brakes", &a->UDPPacket::m_anti_lock_brakes, "xsd:float"))
				{	soap_flag_m_anti_lock_brakes1--;
					continue;
				}
			}
			if (soap_flag_m_fuel_in_tank1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_float(soap, "m-fuel-in-tank", &a->UDPPacket::m_fuel_in_tank, "xsd:float"))
				{	soap_flag_m_fuel_in_tank1--;
					continue;
				}
			}
			if (soap_flag_m_fuel_capacity1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_float(soap, "m-fuel-capacity", &a->UDPPacket::m_fuel_capacity, "xsd:float"))
				{	soap_flag_m_fuel_capacity1--;
					continue;
				}
			}
			if (soap_flag_m_in_pits1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_float(soap, "m-in-pits", &a->UDPPacket::m_in_pits, "xsd:float"))
				{	soap_flag_m_in_pits1--;
					continue;
				}
			}
			if (soap_flag_m_sector1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_float(soap, "m-sector", &a->UDPPacket::m_sector, "xsd:float"))
				{	soap_flag_m_sector1--;
					continue;
				}
			}
			if (soap_flag_m_sector1_time1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_float(soap, "m-sector1-time", &a->UDPPacket::m_sector1_time, "xsd:float"))
				{	soap_flag_m_sector1_time1--;
					continue;
				}
			}
			if (soap_flag_m_sector2_time1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_float(soap, "m-sector2-time", &a->UDPPacket::m_sector2_time, "xsd:float"))
				{	soap_flag_m_sector2_time1--;
					continue;
				}
			}
			if (soap_flag_m_brakes_temp1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_Array4Offloat(soap, "m-brakes-temp", a->UDPPacket::m_brakes_temp, "xsd:float"))
				{	soap_flag_m_brakes_temp1--;
					continue;
				}
			}
			if (soap_flag_m_tyres_pressure1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_Array4Offloat(soap, "m-tyres-pressure", a->UDPPacket::m_tyres_pressure, "xsd:float"))
				{	soap_flag_m_tyres_pressure1--;
					continue;
				}
			}
			if (soap_flag_m_team_info1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_float(soap, "m-team-info", &a->UDPPacket::m_team_info, "xsd:float"))
				{	soap_flag_m_team_info1--;
					continue;
				}
			}
			if (soap_flag_m_total_laps1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_float(soap, "m-total-laps", &a->UDPPacket::m_total_laps, "xsd:float"))
				{	soap_flag_m_total_laps1--;
					continue;
				}
			}
			if (soap_flag_m_track_size1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_float(soap, "m-track-size", &a->UDPPacket::m_track_size, "xsd:float"))
				{	soap_flag_m_track_size1--;
					continue;
				}
			}
			if (soap_flag_m_last_lap_time1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_float(soap, "m-last-lap-time", &a->UDPPacket::m_last_lap_time, "xsd:float"))
				{	soap_flag_m_last_lap_time1--;
					continue;
				}
			}
			if (soap_flag_m_max_rpm1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_float(soap, "m-max-rpm", &a->UDPPacket::m_max_rpm, "xsd:float"))
				{	soap_flag_m_max_rpm1--;
					continue;
				}
			}
			if (soap_flag_m_idle_rpm1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_float(soap, "m-idle-rpm", &a->UDPPacket::m_idle_rpm, "xsd:float"))
				{	soap_flag_m_idle_rpm1--;
					continue;
				}
			}
			if (soap_flag_m_max_gears1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_float(soap, "m-max-gears", &a->UDPPacket::m_max_gears, "xsd:float"))
				{	soap_flag_m_max_gears1--;
					continue;
				}
			}
			if (soap_flag_m_sessionType1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_float(soap, "m-sessionType", &a->UDPPacket::m_sessionType, "xsd:float"))
				{	soap_flag_m_sessionType1--;
					continue;
				}
			}
			if (soap_flag_m_drsAllowed1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_float(soap, "m-drsAllowed", &a->UDPPacket::m_drsAllowed, "xsd:float"))
				{	soap_flag_m_drsAllowed1--;
					continue;
				}
			}
			if (soap_flag_m_track_number1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_float(soap, "m-track-number", &a->UDPPacket::m_track_number, "xsd:float"))
				{	soap_flag_m_track_number1--;
					continue;
				}
			}
			if (soap_flag_m_vehicleFIAFlags1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_float(soap, "m-vehicleFIAFlags", &a->UDPPacket::m_vehicleFIAFlags, "xsd:float"))
				{	soap_flag_m_vehicleFIAFlags1--;
					continue;
				}
			}
			if (soap_flag_m_era1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_float(soap, "m-era", &a->UDPPacket::m_era, "xsd:float"))
				{	soap_flag_m_era1--;
					continue;
				}
			}
			if (soap_flag_m_engine_temperature1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_float(soap, "m-engine-temperature", &a->UDPPacket::m_engine_temperature, "xsd:float"))
				{	soap_flag_m_engine_temperature1--;
					continue;
				}
			}
			if (soap_flag_m_gforce_vert1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_float(soap, "m-gforce-vert", &a->UDPPacket::m_gforce_vert, "xsd:float"))
				{	soap_flag_m_gforce_vert1--;
					continue;
				}
			}
			if (soap_flag_m_ang_vel_x1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_float(soap, "m-ang-vel-x", &a->UDPPacket::m_ang_vel_x, "xsd:float"))
				{	soap_flag_m_ang_vel_x1--;
					continue;
				}
			}
			if (soap_flag_m_ang_vel_y1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_float(soap, "m-ang-vel-y", &a->UDPPacket::m_ang_vel_y, "xsd:float"))
				{	soap_flag_m_ang_vel_y1--;
					continue;
				}
			}
			if (soap_flag_m_ang_vel_z1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_float(soap, "m-ang-vel-z", &a->UDPPacket::m_ang_vel_z, "xsd:float"))
				{	soap_flag_m_ang_vel_z1--;
					continue;
				}
			}
			if (soap_flag_m_tyres_temperature1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_Array4Ofbyte(soap, "m-tyres-temperature", a->UDPPacket::m_tyres_temperature, "xsd:byte"))
				{	soap_flag_m_tyres_temperature1--;
					continue;
				}
			}
			if (soap_flag_m_tyres_wear1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_Array4Ofbyte(soap, "m-tyres-wear", a->UDPPacket::m_tyres_wear, "xsd:byte"))
				{	soap_flag_m_tyres_wear1--;
					continue;
				}
			}
			if (soap_flag_m_tyre_compound1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_byte(soap, "m-tyre-compound", &a->UDPPacket::m_tyre_compound, "xsd:byte"))
				{	soap_flag_m_tyre_compound1--;
					continue;
				}
			}
			if (soap_flag_m_front_brake_bias1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_byte(soap, "m-front-brake-bias", &a->UDPPacket::m_front_brake_bias, "xsd:byte"))
				{	soap_flag_m_front_brake_bias1--;
					continue;
				}
			}
			if (soap_flag_m_fuel_mix1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_byte(soap, "m-fuel-mix", &a->UDPPacket::m_fuel_mix, "xsd:byte"))
				{	soap_flag_m_fuel_mix1--;
					continue;
				}
			}
			if (soap_flag_m_currentLapInvalid1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_byte(soap, "m-currentLapInvalid", &a->UDPPacket::m_currentLapInvalid, "xsd:byte"))
				{	soap_flag_m_currentLapInvalid1--;
					continue;
				}
			}
			if (soap_flag_m_tyres_damage1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_Array4Ofbyte(soap, "m-tyres-damage", a->UDPPacket::m_tyres_damage, "xsd:byte"))
				{	soap_flag_m_tyres_damage1--;
					continue;
				}
			}
			if (soap_flag_m_front_left_wing_damage1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_byte(soap, "m-front-left-wing-damage", &a->UDPPacket::m_front_left_wing_damage, "xsd:byte"))
				{	soap_flag_m_front_left_wing_damage1--;
					continue;
				}
			}
			if (soap_flag_m_front_right_wing_damage1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_byte(soap, "m-front-right-wing-damage", &a->UDPPacket::m_front_right_wing_damage, "xsd:byte"))
				{	soap_flag_m_front_right_wing_damage1--;
					continue;
				}
			}
			if (soap_flag_m_rear_wing_damage1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_byte(soap, "m-rear-wing-damage", &a->UDPPacket::m_rear_wing_damage, "xsd:byte"))
				{	soap_flag_m_rear_wing_damage1--;
					continue;
				}
			}
			if (soap_flag_m_engine_damage1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_byte(soap, "m-engine-damage", &a->UDPPacket::m_engine_damage, "xsd:byte"))
				{	soap_flag_m_engine_damage1--;
					continue;
				}
			}
			if (soap_flag_m_gear_box_damage1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_byte(soap, "m-gear-box-damage", &a->UDPPacket::m_gear_box_damage, "xsd:byte"))
				{	soap_flag_m_gear_box_damage1--;
					continue;
				}
			}
			if (soap_flag_m_exhaust_damage1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_byte(soap, "m-exhaust-damage", &a->UDPPacket::m_exhaust_damage, "xsd:byte"))
				{	soap_flag_m_exhaust_damage1--;
					continue;
				}
			}
			if (soap_flag_m_pit_limiter_status1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_byte(soap, "m-pit-limiter-status", &a->UDPPacket::m_pit_limiter_status, "xsd:byte"))
				{	soap_flag_m_pit_limiter_status1--;
					continue;
				}
			}
			if (soap_flag_m_pit_speed_limit1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_byte(soap, "m-pit-speed-limit", &a->UDPPacket::m_pit_speed_limit, "xsd:byte"))
				{	soap_flag_m_pit_speed_limit1--;
					continue;
				}
			}
			if (soap_flag_m_session_time_left1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_float(soap, "m-session-time-left", &a->UDPPacket::m_session_time_left, "xsd:float"))
				{	soap_flag_m_session_time_left1--;
					continue;
				}
			}
			if (soap_flag_m_rev_lights_percent1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_byte(soap, "m-rev-lights-percent", &a->UDPPacket::m_rev_lights_percent, "xsd:byte"))
				{	soap_flag_m_rev_lights_percent1--;
					continue;
				}
			}
			if (soap_flag_m_is_spectating1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_byte(soap, "m-is-spectating", &a->UDPPacket::m_is_spectating, "xsd:byte"))
				{	soap_flag_m_is_spectating1--;
					continue;
				}
			}
			if (soap_flag_m_spectator_car_index1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_byte(soap, "m-spectator-car-index", &a->UDPPacket::m_spectator_car_index, "xsd:byte"))
				{	soap_flag_m_spectator_car_index1--;
					continue;
				}
			}
			if (soap_flag_m_num_cars1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_byte(soap, "m-num-cars", &a->UDPPacket::m_num_cars, "xsd:byte"))
				{	soap_flag_m_num_cars1--;
					continue;
				}
			}
			if (soap_flag_m_player_car_index1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_byte(soap, "m-player-car-index", &a->UDPPacket::m_player_car_index, "xsd:byte"))
				{	soap_flag_m_player_car_index1--;
					continue;
				}
			}
			if (soap_flag_m_car_data1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_Array20OfCarUDPData(soap, "m-car-data", a->UDPPacket::m_car_data, "CarUDPData"))
				{	soap_flag_m_car_data1--;
					continue;
				}
			}
			if (soap_flag_m_yaw1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_float(soap, "m-yaw", &a->UDPPacket::m_yaw, "xsd:float"))
				{	soap_flag_m_yaw1--;
					continue;
				}
			}
			if (soap_flag_m_pitch1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_float(soap, "m-pitch", &a->UDPPacket::m_pitch, "xsd:float"))
				{	soap_flag_m_pitch1--;
					continue;
				}
			}
			if (soap_flag_m_roll1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_float(soap, "m-roll", &a->UDPPacket::m_roll, "xsd:float"))
				{	soap_flag_m_roll1--;
					continue;
				}
			}
			if (soap_flag_m_x_local_velocity1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_float(soap, "m-x-local-velocity", &a->UDPPacket::m_x_local_velocity, "xsd:float"))
				{	soap_flag_m_x_local_velocity1--;
					continue;
				}
			}
			if (soap_flag_m_y_local_velocity1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_float(soap, "m-y-local-velocity", &a->UDPPacket::m_y_local_velocity, "xsd:float"))
				{	soap_flag_m_y_local_velocity1--;
					continue;
				}
			}
			if (soap_flag_m_z_local_velocity1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_float(soap, "m-z-local-velocity", &a->UDPPacket::m_z_local_velocity, "xsd:float"))
				{	soap_flag_m_z_local_velocity1--;
					continue;
				}
			}
			if (soap_flag_m_susp_acceleration1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_Array4Offloat(soap, "m-susp-acceleration", a->UDPPacket::m_susp_acceleration, "xsd:float"))
				{	soap_flag_m_susp_acceleration1--;
					continue;
				}
			}
			if (soap_flag_m_ang_acc_x1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_float(soap, "m-ang-acc-x", &a->UDPPacket::m_ang_acc_x, "xsd:float"))
				{	soap_flag_m_ang_acc_x1--;
					continue;
				}
			}
			if (soap_flag_m_ang_acc_y1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_float(soap, "m-ang-acc-y", &a->UDPPacket::m_ang_acc_y, "xsd:float"))
				{	soap_flag_m_ang_acc_y1--;
					continue;
				}
			}
			if (soap_flag_m_ang_acc_z1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_float(soap, "m-ang-acc-z", &a->UDPPacket::m_ang_acc_z, "xsd:float"))
				{	soap_flag_m_ang_acc_z1--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_m_time1 > 0 || soap_flag_m_lapTime1 > 0 || soap_flag_m_lapDistance1 > 0 || soap_flag_m_totalDistance1 > 0 || soap_flag_m_x1 > 0 || soap_flag_m_y1 > 0 || soap_flag_m_z1 > 0 || soap_flag_m_speed1 > 0 || soap_flag_m_xv1 > 0 || soap_flag_m_yv1 > 0 || soap_flag_m_zv1 > 0 || soap_flag_m_xr1 > 0 || soap_flag_m_yr1 > 0 || soap_flag_m_zr1 > 0 || soap_flag_m_xd1 > 0 || soap_flag_m_yd1 > 0 || soap_flag_m_zd1 > 0 || soap_flag_m_susp_pos1 > 0 || soap_flag_m_susp_vel1 > 0 || soap_flag_m_wheel_speed1 > 0 || soap_flag_m_throttle1 > 0 || soap_flag_m_steer1 > 0 || soap_flag_m_brake1 > 0 || soap_flag_m_clutch1 > 0 || soap_flag_m_gear1 > 0 || soap_flag_m_gforce_lat1 > 0 || soap_flag_m_gforce_lon1 > 0 || soap_flag_m_lap1 > 0 || soap_flag_m_engineRate1 > 0 || soap_flag_m_sli_pro_native_support1 > 0 || soap_flag_m_car_position1 > 0 || soap_flag_m_kers_level1 > 0 || soap_flag_m_kers_max_level1 > 0 || soap_flag_m_drs1 > 0 || soap_flag_m_traction_control1 > 0 || soap_flag_m_anti_lock_brakes1 > 0 || soap_flag_m_fuel_in_tank1 > 0 || soap_flag_m_fuel_capacity1 > 0 || soap_flag_m_in_pits1 > 0 || soap_flag_m_sector1 > 0 || soap_flag_m_sector1_time1 > 0 || soap_flag_m_sector2_time1 > 0 || soap_flag_m_brakes_temp1 > 0 || soap_flag_m_tyres_pressure1 > 0 || soap_flag_m_team_info1 > 0 || soap_flag_m_total_laps1 > 0 || soap_flag_m_track_size1 > 0 || soap_flag_m_last_lap_time1 > 0 || soap_flag_m_max_rpm1 > 0 || soap_flag_m_idle_rpm1 > 0 || soap_flag_m_max_gears1 > 0 || soap_flag_m_sessionType1 > 0 || soap_flag_m_drsAllowed1 > 0 || soap_flag_m_track_number1 > 0 || soap_flag_m_vehicleFIAFlags1 > 0 || soap_flag_m_era1 > 0 || soap_flag_m_engine_temperature1 > 0 || soap_flag_m_gforce_vert1 > 0 || soap_flag_m_ang_vel_x1 > 0 || soap_flag_m_ang_vel_y1 > 0 || soap_flag_m_ang_vel_z1 > 0 || soap_flag_m_tyres_temperature1 > 0 || soap_flag_m_tyres_wear1 > 0 || soap_flag_m_tyre_compound1 > 0 || soap_flag_m_front_brake_bias1 > 0 || soap_flag_m_fuel_mix1 > 0 || soap_flag_m_currentLapInvalid1 > 0 || soap_flag_m_tyres_damage1 > 0 || soap_flag_m_front_left_wing_damage1 > 0 || soap_flag_m_front_right_wing_damage1 > 0 || soap_flag_m_rear_wing_damage1 > 0 || soap_flag_m_engine_damage1 > 0 || soap_flag_m_gear_box_damage1 > 0 || soap_flag_m_exhaust_damage1 > 0 || soap_flag_m_pit_limiter_status1 > 0 || soap_flag_m_pit_speed_limit1 > 0 || soap_flag_m_session_time_left1 > 0 || soap_flag_m_rev_lights_percent1 > 0 || soap_flag_m_is_spectating1 > 0 || soap_flag_m_spectator_car_index1 > 0 || soap_flag_m_num_cars1 > 0 || soap_flag_m_player_car_index1 > 0 || soap_flag_m_car_data1 > 0 || soap_flag_m_yaw1 > 0 || soap_flag_m_pitch1 > 0 || soap_flag_m_roll1 > 0 || soap_flag_m_x_local_velocity1 > 0 || soap_flag_m_y_local_velocity1 > 0 || soap_flag_m_z_local_velocity1 > 0 || soap_flag_m_susp_acceleration1 > 0 || soap_flag_m_ang_acc_x1 > 0 || soap_flag_m_ang_acc_y1 > 0 || soap_flag_m_ang_acc_z1 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (UDPPacket *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_deepf1_gsoap_UDPPacket, SOAP_TYPE_deepf1_gsoap_UDPPacket, sizeof(UDPPacket), 0, deepf1_gsoap_finsert, deepf1_gsoap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 UDPPacket * SOAP_FMAC2 soap_instantiate_UDPPacket(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_UDPPacket(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	UDPPacket *p;
	size_t k = sizeof(UDPPacket);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_deepf1_gsoap_UDPPacket, n, deepf1_gsoap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, UDPPacket);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, UDPPacket, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated UDPPacket location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int UDPPacket::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_UDPPacket(soap, tag ? tag : "UDPPacket", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *UDPPacket::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_UDPPacket(soap, this, tag, type);
}

SOAP_FMAC3 UDPPacket * SOAP_FMAC4 soap_get_UDPPacket(struct soap *soap, UDPPacket *p, const char *tag, const char *type)
{
	if ((p = soap_in_UDPPacket(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void CarUDPData::soap_default(struct soap *soap)
{
	(void)soap; /* appease -Wall -Werror */
	soap_default_Array3Offloat(soap, this->CarUDPData::m_worldPosition);
	soap_default_float(soap, &this->CarUDPData::m_lastLapTime);
	soap_default_float(soap, &this->CarUDPData::m_currentLapTime);
	soap_default_float(soap, &this->CarUDPData::m_bestLapTime);
	soap_default_float(soap, &this->CarUDPData::m_sector1Time);
	soap_default_float(soap, &this->CarUDPData::m_sector2Time);
	soap_default_float(soap, &this->CarUDPData::m_lapDistance);
	soap_default_byte(soap, &this->CarUDPData::m_driverId);
	soap_default_byte(soap, &this->CarUDPData::m_teamId);
	soap_default_byte(soap, &this->CarUDPData::m_carPosition);
	soap_default_byte(soap, &this->CarUDPData::m_currentLapNum);
	soap_default_byte(soap, &this->CarUDPData::m_tyreCompound);
	soap_default_byte(soap, &this->CarUDPData::m_inPits);
	soap_default_byte(soap, &this->CarUDPData::m_sector);
	soap_default_byte(soap, &this->CarUDPData::m_currentLapInvalid);
	soap_default_byte(soap, &this->CarUDPData::m_penalties);
}

void CarUDPData::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_Array3Offloat(soap, this->CarUDPData::m_worldPosition);
	soap_embedded(soap, &this->CarUDPData::m_driverId, SOAP_TYPE_deepf1_gsoap_byte);
	soap_embedded(soap, &this->CarUDPData::m_teamId, SOAP_TYPE_deepf1_gsoap_byte);
	soap_embedded(soap, &this->CarUDPData::m_carPosition, SOAP_TYPE_deepf1_gsoap_byte);
	soap_embedded(soap, &this->CarUDPData::m_currentLapNum, SOAP_TYPE_deepf1_gsoap_byte);
	soap_embedded(soap, &this->CarUDPData::m_tyreCompound, SOAP_TYPE_deepf1_gsoap_byte);
	soap_embedded(soap, &this->CarUDPData::m_inPits, SOAP_TYPE_deepf1_gsoap_byte);
	soap_embedded(soap, &this->CarUDPData::m_sector, SOAP_TYPE_deepf1_gsoap_byte);
	soap_embedded(soap, &this->CarUDPData::m_currentLapInvalid, SOAP_TYPE_deepf1_gsoap_byte);
	soap_embedded(soap, &this->CarUDPData::m_penalties, SOAP_TYPE_deepf1_gsoap_byte);
#endif
}

int CarUDPData::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_CarUDPData(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_CarUDPData(struct soap *soap, const char *tag, int id, const CarUDPData *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_deepf1_gsoap_CarUDPData), type))
		return soap->error;
	if (soap_out_Array3Offloat(soap, "m-worldPosition", -1, a->CarUDPData::m_worldPosition, ""))
		return soap->error;
	if (soap_out_float(soap, "m-lastLapTime", -1, &a->CarUDPData::m_lastLapTime, ""))
		return soap->error;
	if (soap_out_float(soap, "m-currentLapTime", -1, &a->CarUDPData::m_currentLapTime, ""))
		return soap->error;
	if (soap_out_float(soap, "m-bestLapTime", -1, &a->CarUDPData::m_bestLapTime, ""))
		return soap->error;
	if (soap_out_float(soap, "m-sector1Time", -1, &a->CarUDPData::m_sector1Time, ""))
		return soap->error;
	if (soap_out_float(soap, "m-sector2Time", -1, &a->CarUDPData::m_sector2Time, ""))
		return soap->error;
	if (soap_out_float(soap, "m-lapDistance", -1, &a->CarUDPData::m_lapDistance, ""))
		return soap->error;
	if (soap_out_byte(soap, "m-driverId", -1, &a->CarUDPData::m_driverId, ""))
		return soap->error;
	if (soap_out_byte(soap, "m-teamId", -1, &a->CarUDPData::m_teamId, ""))
		return soap->error;
	if (soap_out_byte(soap, "m-carPosition", -1, &a->CarUDPData::m_carPosition, ""))
		return soap->error;
	if (soap_out_byte(soap, "m-currentLapNum", -1, &a->CarUDPData::m_currentLapNum, ""))
		return soap->error;
	if (soap_out_byte(soap, "m-tyreCompound", -1, &a->CarUDPData::m_tyreCompound, ""))
		return soap->error;
	if (soap_out_byte(soap, "m-inPits", -1, &a->CarUDPData::m_inPits, ""))
		return soap->error;
	if (soap_out_byte(soap, "m-sector", -1, &a->CarUDPData::m_sector, ""))
		return soap->error;
	if (soap_out_byte(soap, "m-currentLapInvalid", -1, &a->CarUDPData::m_currentLapInvalid, ""))
		return soap->error;
	if (soap_out_byte(soap, "m-penalties", -1, &a->CarUDPData::m_penalties, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *CarUDPData::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_CarUDPData(soap, tag, this, type);
}

SOAP_FMAC3 CarUDPData * SOAP_FMAC4 soap_in_CarUDPData(struct soap *soap, const char *tag, CarUDPData *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (CarUDPData *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_deepf1_gsoap_CarUDPData, sizeof(CarUDPData), soap->type, soap->arrayType, deepf1_gsoap_instantiate, deepf1_gsoap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_deepf1_gsoap_CarUDPData)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (CarUDPData *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_m_worldPosition1 = 1;
	size_t soap_flag_m_lastLapTime1 = 1;
	size_t soap_flag_m_currentLapTime1 = 1;
	size_t soap_flag_m_bestLapTime1 = 1;
	size_t soap_flag_m_sector1Time1 = 1;
	size_t soap_flag_m_sector2Time1 = 1;
	size_t soap_flag_m_lapDistance1 = 1;
	size_t soap_flag_m_driverId1 = 1;
	size_t soap_flag_m_teamId1 = 1;
	size_t soap_flag_m_carPosition1 = 1;
	size_t soap_flag_m_currentLapNum1 = 1;
	size_t soap_flag_m_tyreCompound1 = 1;
	size_t soap_flag_m_inPits1 = 1;
	size_t soap_flag_m_sector1 = 1;
	size_t soap_flag_m_currentLapInvalid1 = 1;
	size_t soap_flag_m_penalties1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_m_worldPosition1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_Array3Offloat(soap, "m-worldPosition", a->CarUDPData::m_worldPosition, "xsd:float"))
				{	soap_flag_m_worldPosition1--;
					continue;
				}
			}
			if (soap_flag_m_lastLapTime1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_float(soap, "m-lastLapTime", &a->CarUDPData::m_lastLapTime, "xsd:float"))
				{	soap_flag_m_lastLapTime1--;
					continue;
				}
			}
			if (soap_flag_m_currentLapTime1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_float(soap, "m-currentLapTime", &a->CarUDPData::m_currentLapTime, "xsd:float"))
				{	soap_flag_m_currentLapTime1--;
					continue;
				}
			}
			if (soap_flag_m_bestLapTime1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_float(soap, "m-bestLapTime", &a->CarUDPData::m_bestLapTime, "xsd:float"))
				{	soap_flag_m_bestLapTime1--;
					continue;
				}
			}
			if (soap_flag_m_sector1Time1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_float(soap, "m-sector1Time", &a->CarUDPData::m_sector1Time, "xsd:float"))
				{	soap_flag_m_sector1Time1--;
					continue;
				}
			}
			if (soap_flag_m_sector2Time1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_float(soap, "m-sector2Time", &a->CarUDPData::m_sector2Time, "xsd:float"))
				{	soap_flag_m_sector2Time1--;
					continue;
				}
			}
			if (soap_flag_m_lapDistance1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_float(soap, "m-lapDistance", &a->CarUDPData::m_lapDistance, "xsd:float"))
				{	soap_flag_m_lapDistance1--;
					continue;
				}
			}
			if (soap_flag_m_driverId1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_byte(soap, "m-driverId", &a->CarUDPData::m_driverId, "xsd:byte"))
				{	soap_flag_m_driverId1--;
					continue;
				}
			}
			if (soap_flag_m_teamId1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_byte(soap, "m-teamId", &a->CarUDPData::m_teamId, "xsd:byte"))
				{	soap_flag_m_teamId1--;
					continue;
				}
			}
			if (soap_flag_m_carPosition1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_byte(soap, "m-carPosition", &a->CarUDPData::m_carPosition, "xsd:byte"))
				{	soap_flag_m_carPosition1--;
					continue;
				}
			}
			if (soap_flag_m_currentLapNum1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_byte(soap, "m-currentLapNum", &a->CarUDPData::m_currentLapNum, "xsd:byte"))
				{	soap_flag_m_currentLapNum1--;
					continue;
				}
			}
			if (soap_flag_m_tyreCompound1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_byte(soap, "m-tyreCompound", &a->CarUDPData::m_tyreCompound, "xsd:byte"))
				{	soap_flag_m_tyreCompound1--;
					continue;
				}
			}
			if (soap_flag_m_inPits1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_byte(soap, "m-inPits", &a->CarUDPData::m_inPits, "xsd:byte"))
				{	soap_flag_m_inPits1--;
					continue;
				}
			}
			if (soap_flag_m_sector1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_byte(soap, "m-sector", &a->CarUDPData::m_sector, "xsd:byte"))
				{	soap_flag_m_sector1--;
					continue;
				}
			}
			if (soap_flag_m_currentLapInvalid1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_byte(soap, "m-currentLapInvalid", &a->CarUDPData::m_currentLapInvalid, "xsd:byte"))
				{	soap_flag_m_currentLapInvalid1--;
					continue;
				}
			}
			if (soap_flag_m_penalties1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_byte(soap, "m-penalties", &a->CarUDPData::m_penalties, "xsd:byte"))
				{	soap_flag_m_penalties1--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_m_worldPosition1 > 0 || soap_flag_m_lastLapTime1 > 0 || soap_flag_m_currentLapTime1 > 0 || soap_flag_m_bestLapTime1 > 0 || soap_flag_m_sector1Time1 > 0 || soap_flag_m_sector2Time1 > 0 || soap_flag_m_lapDistance1 > 0 || soap_flag_m_driverId1 > 0 || soap_flag_m_teamId1 > 0 || soap_flag_m_carPosition1 > 0 || soap_flag_m_currentLapNum1 > 0 || soap_flag_m_tyreCompound1 > 0 || soap_flag_m_inPits1 > 0 || soap_flag_m_sector1 > 0 || soap_flag_m_currentLapInvalid1 > 0 || soap_flag_m_penalties1 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (CarUDPData *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_deepf1_gsoap_CarUDPData, SOAP_TYPE_deepf1_gsoap_CarUDPData, sizeof(CarUDPData), 0, deepf1_gsoap_finsert, deepf1_gsoap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 CarUDPData * SOAP_FMAC2 soap_instantiate_CarUDPData(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_CarUDPData(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	CarUDPData *p;
	size_t k = sizeof(CarUDPData);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_deepf1_gsoap_CarUDPData, n, deepf1_gsoap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, CarUDPData);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, CarUDPData, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated CarUDPData location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int CarUDPData::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_CarUDPData(soap, tag ? tag : "CarUDPData", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *CarUDPData::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_CarUDPData(soap, this, tag, type);
}

SOAP_FMAC3 CarUDPData * SOAP_FMAC4 soap_get_CarUDPData(struct soap *soap, CarUDPData *p, const char *tag, const char *type)
{
	if ((p = soap_in_CarUDPData(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTostd__string(struct soap *soap, std::string *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_deepf1_gsoap_std__string))
		soap_serialize_std__string(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTostd__string(struct soap *soap, const char *tag, int id, std::string *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_deepf1_gsoap_std__string, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_std__string(soap, tag, id, *a, type);
}

SOAP_FMAC3 std::string ** SOAP_FMAC4 soap_in_PointerTostd__string(struct soap *soap, const char *tag, std::string **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (std::string **)soap_malloc(soap, sizeof(std::string *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_std__string(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (std::string **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_deepf1_gsoap_std__string, sizeof(std::string), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTostd__string(struct soap *soap, std::string *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTostd__string(soap, tag ? tag : "string", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 std::string ** SOAP_FMAC4 soap_get_PointerTostd__string(struct soap *soap, std::string **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTostd__string(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToground_truth_sample(struct soap *soap, ground_truth_sample *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_deepf1_gsoap_ground_truth_sample))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToground_truth_sample(struct soap *soap, const char *tag, int id, ground_truth_sample *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_deepf1_gsoap_ground_truth_sample, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_deepf1_gsoap_ground_truth_sample ? type : NULL);
}

SOAP_FMAC3 ground_truth_sample ** SOAP_FMAC4 soap_in_PointerToground_truth_sample(struct soap *soap, const char *tag, ground_truth_sample **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ground_truth_sample **)soap_malloc(soap, sizeof(ground_truth_sample *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ground_truth_sample *)soap_instantiate_ground_truth_sample(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (ground_truth_sample **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_deepf1_gsoap_ground_truth_sample, sizeof(ground_truth_sample), 0, deepf1_gsoap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToground_truth_sample(struct soap *soap, ground_truth_sample *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerToground_truth_sample(soap, tag ? tag : "ground-truth-sample", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ground_truth_sample ** SOAP_FMAC4 soap_get_PointerToground_truth_sample(struct soap *soap, ground_truth_sample **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToground_truth_sample(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToUDPPacket(struct soap *soap, UDPPacket *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_deepf1_gsoap_UDPPacket))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToUDPPacket(struct soap *soap, const char *tag, int id, UDPPacket *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_deepf1_gsoap_UDPPacket, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_deepf1_gsoap_UDPPacket ? type : NULL);
}

SOAP_FMAC3 UDPPacket ** SOAP_FMAC4 soap_in_PointerToUDPPacket(struct soap *soap, const char *tag, UDPPacket **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (UDPPacket **)soap_malloc(soap, sizeof(UDPPacket *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (UDPPacket *)soap_instantiate_UDPPacket(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (UDPPacket **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_deepf1_gsoap_UDPPacket, sizeof(UDPPacket), 0, deepf1_gsoap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToUDPPacket(struct soap *soap, UDPPacket *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerToUDPPacket(soap, tag ? tag : "UDPPacket", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 UDPPacket ** SOAP_FMAC4 soap_get_PointerToUDPPacket(struct soap *soap, UDPPacket **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToUDPPacket(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToCarUDPData(struct soap *soap, CarUDPData *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_deepf1_gsoap_CarUDPData))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToCarUDPData(struct soap *soap, const char *tag, int id, CarUDPData *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_deepf1_gsoap_CarUDPData, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_deepf1_gsoap_CarUDPData ? type : NULL);
}

SOAP_FMAC3 CarUDPData ** SOAP_FMAC4 soap_in_PointerToCarUDPData(struct soap *soap, const char *tag, CarUDPData **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (CarUDPData **)soap_malloc(soap, sizeof(CarUDPData *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (CarUDPData *)soap_instantiate_CarUDPData(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (CarUDPData **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_deepf1_gsoap_CarUDPData, sizeof(CarUDPData), 0, deepf1_gsoap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToCarUDPData(struct soap *soap, CarUDPData *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerToCarUDPData(soap, tag ? tag : "CarUDPData", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 CarUDPData ** SOAP_FMAC4 soap_get_PointerToCarUDPData(struct soap *soap, CarUDPData **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToCarUDPData(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__QName(struct soap *soap, char *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	(void)soap_reference(soap, *a, SOAP_TYPE_deepf1_gsoap__QName);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__QName(struct soap *soap, const char *tag, int id, char *const*a, const char *type)
{
	return soap_outstring(soap, tag, id, a, type, SOAP_TYPE_deepf1_gsoap__QName);
}

SOAP_FMAC3 char * * SOAP_FMAC4 soap_in__QName(struct soap *soap, const char *tag, char **a, const char *type)
{
	a = soap_instring(soap, tag, a, type, SOAP_TYPE_deepf1_gsoap__QName, 2, 0, -1, NULL);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__QName(struct soap *soap, char *const*a, const char *tag, const char *type)
{
	if (soap_out__QName(soap, tag ? tag : "QName", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 char ** SOAP_FMAC4 soap_get__QName(struct soap *soap, char **p, const char *tag, const char *type)
{
	if ((p = soap_in__QName(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_string(struct soap *soap, char *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	(void)soap_reference(soap, *a, SOAP_TYPE_deepf1_gsoap_string);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_string(struct soap *soap, const char *tag, int id, char *const*a, const char *type)
{
	return soap_outstring(soap, tag, id, a, type, SOAP_TYPE_deepf1_gsoap_string);
}

SOAP_FMAC3 char * * SOAP_FMAC4 soap_in_string(struct soap *soap, const char *tag, char **a, const char *type)
{
	a = soap_instring(soap, tag, a, type, SOAP_TYPE_deepf1_gsoap_string, 1, 0, -1, NULL);
	return a;
}

SOAP_FMAC3 char * * SOAP_FMAC4 soap_new_string(struct soap *soap, int n)
{
	char * *a = static_cast<char * *>(soap_malloc(soap, (n = (n < 0 ? 1 : n)) * sizeof(char *)));
	for (char * *p = a; p && n--; ++p)
		soap_default_string(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_string(struct soap *soap, char *const*a, const char *tag, const char *type)
{
	if (soap_out_string(soap, tag ? tag : "string", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 char ** SOAP_FMAC4 soap_get_string(struct soap *soap, char **p, const char *tag, const char *type)
{
	if ((p = soap_in_string(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_Array20OfCarUDPData(struct soap *soap, CarUDPData a[20])
{
	int i;
	(void)soap; /* appease -Wall -Werror */
	for (i = 0; i < 20; i++)(a+i)->soap_default(soap);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_Array20OfCarUDPData(struct soap *soap, CarUDPData const a[20])
{
	int i;
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	for (i = 0; i < 20; i++)
	{	soap_embedded(soap, a+i, SOAP_TYPE_deepf1_gsoap_CarUDPData);
	a[i].soap_serialize(soap);
	}
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_Array20OfCarUDPData(struct soap *soap, const char *tag, int id, CarUDPData const a[20], const char *type)
{
	size_t i;
	(void)type;
	soap_array_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_deepf1_gsoap_Array20OfCarUDPData), "CarUDPData[20]", 0);
	for (i = 0; i < 20; i++)
	{
		if ((a+i)->soap_out(soap, "item", -1, ""))
			return soap->error;
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 CarUDPData * SOAP_FMAC4 soap_in_Array20OfCarUDPData(struct soap *soap, const char *tag, CarUDPData a[20], const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	if (soap_match_array(soap, type))
	{	soap->error = SOAP_TYPE;
		return NULL;
	}
	a = (CarUDPData (*))soap_id_enter(soap, soap->id, a, SOAP_TYPE_deepf1_gsoap_Array20OfCarUDPData, sizeof(CarUDPData[20]), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_Array20OfCarUDPData(soap, a);
	if (soap->body && *soap->href != '#')
	{	int i;
		for (i = 0; i < 20; i++)
		{	soap_peek_element(soap);
			if (soap->position)
			{	i = soap->positions[0];
				if (i < 0 || i >= 20)
				{	soap->error = SOAP_IOB;
					return NULL;
				}
			}
			if (!soap_in_CarUDPData(soap, NULL, a+i, "CarUDPData"))
			{	if (soap->error != SOAP_NO_TAG)
					return NULL;
				soap->error = SOAP_OK;
				break;
			}
		}
		if (soap->mode & SOAP_C_NOIOB)
			while (soap_element_end_in(soap, tag) == SOAP_SYNTAX_ERROR)
			{	soap->peeked = 1;
				soap_ignore_element(soap);
			}
		else if (soap_element_end_in(soap, tag))
		{	if (soap->error == SOAP_SYNTAX_ERROR)
				soap->error = SOAP_IOB;
			return NULL;
		}
	}
	else
	{	a = (CarUDPData (*))soap_id_forward(soap, soap->href, (void*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_deepf1_gsoap_Array20OfCarUDPData, sizeof(CarUDPData[20]), NULL, NULL, NULL, NULL), 0, SOAP_TYPE_deepf1_gsoap_Array20OfCarUDPData, SOAP_TYPE_deepf1_gsoap_Array20OfCarUDPData, sizeof(CarUDPData[20]), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return (CarUDPData *)a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_Array20OfCarUDPData(struct soap *soap, CarUDPData const a[20], const char *tag, const char *type)
{
	if (soap_out_Array20OfCarUDPData(soap, tag ? tag : "SOAP-ENC:Array", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 CarUDPData * SOAP_FMAC4 soap_get_Array20OfCarUDPData(struct soap *soap, CarUDPData a[20], const char *tag, const char *type)
{	CarUDPData (*p);
	if ((p = soap_in_Array20OfCarUDPData(soap, tag, a, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_Array4Ofbyte(struct soap *soap, char a[4])
{
	int i;
	(void)soap; /* appease -Wall -Werror */
	for (i = 0; i < 4; i++)
		soap_default_byte(soap, a+i);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_Array4Ofbyte(struct soap *soap, char const a[4])
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_Array4Ofbyte(struct soap *soap, const char *tag, int id, char const a[4], const char *type)
{
	size_t i;
	(void)type;
	soap_array_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_deepf1_gsoap_Array4Ofbyte), "xsd:byte[4]", 0);
	for (i = 0; i < 4; i++)
	{
		if (soap_out_byte(soap, "item", -1, a+i, ""))
			return soap->error;
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 char * SOAP_FMAC4 soap_in_Array4Ofbyte(struct soap *soap, const char *tag, char a[4], const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	if (soap_match_array(soap, type))
	{	soap->error = SOAP_TYPE;
		return NULL;
	}
	a = (char (*))soap_id_enter(soap, soap->id, a, SOAP_TYPE_deepf1_gsoap_Array4Ofbyte, sizeof(char[4]), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_Array4Ofbyte(soap, a);
	if (soap->body && *soap->href != '#')
	{	int i;
		for (i = 0; i < 4; i++)
		{	soap_peek_element(soap);
			if (soap->position)
			{	i = soap->positions[0];
				if (i < 0 || i >= 4)
				{	soap->error = SOAP_IOB;
					return NULL;
				}
			}
			if (!soap_in_byte(soap, NULL, a+i, "xsd:byte"))
			{	if (soap->error != SOAP_NO_TAG)
					return NULL;
				soap->error = SOAP_OK;
				break;
			}
		}
		if (soap->mode & SOAP_C_NOIOB)
			while (soap_element_end_in(soap, tag) == SOAP_SYNTAX_ERROR)
			{	soap->peeked = 1;
				soap_ignore_element(soap);
			}
		else if (soap_element_end_in(soap, tag))
		{	if (soap->error == SOAP_SYNTAX_ERROR)
				soap->error = SOAP_IOB;
			return NULL;
		}
	}
	else
	{	a = (char (*))soap_id_forward(soap, soap->href, (void*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_deepf1_gsoap_Array4Ofbyte, sizeof(char[4]), NULL, NULL, NULL, NULL), 0, SOAP_TYPE_deepf1_gsoap_Array4Ofbyte, SOAP_TYPE_deepf1_gsoap_Array4Ofbyte, sizeof(char[4]), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return (char *)a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_Array4Ofbyte(struct soap *soap, char const a[4], const char *tag, const char *type)
{
	if (soap_out_Array4Ofbyte(soap, tag ? tag : "SOAP-ENC:Array", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 char * SOAP_FMAC4 soap_get_Array4Ofbyte(struct soap *soap, char a[4], const char *tag, const char *type)
{	char (*p);
	if ((p = soap_in_Array4Ofbyte(soap, tag, a, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_Array4Offloat(struct soap *soap, float a[4])
{
	int i;
	(void)soap; /* appease -Wall -Werror */
	for (i = 0; i < 4; i++)
		soap_default_float(soap, a+i);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_Array4Offloat(struct soap *soap, float const a[4])
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_Array4Offloat(struct soap *soap, const char *tag, int id, float const a[4], const char *type)
{
	size_t i;
	(void)type;
	soap_array_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_deepf1_gsoap_Array4Offloat), "xsd:float[4]", 0);
	for (i = 0; i < 4; i++)
	{
		if (soap_out_float(soap, "item", -1, a+i, ""))
			return soap->error;
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 float * SOAP_FMAC4 soap_in_Array4Offloat(struct soap *soap, const char *tag, float a[4], const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	if (soap_match_array(soap, type))
	{	soap->error = SOAP_TYPE;
		return NULL;
	}
	a = (float (*))soap_id_enter(soap, soap->id, a, SOAP_TYPE_deepf1_gsoap_Array4Offloat, sizeof(float[4]), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_Array4Offloat(soap, a);
	if (soap->body && *soap->href != '#')
	{	int i;
		for (i = 0; i < 4; i++)
		{	soap_peek_element(soap);
			if (soap->position)
			{	i = soap->positions[0];
				if (i < 0 || i >= 4)
				{	soap->error = SOAP_IOB;
					return NULL;
				}
			}
			if (!soap_in_float(soap, NULL, a+i, "xsd:float"))
			{	if (soap->error != SOAP_NO_TAG)
					return NULL;
				soap->error = SOAP_OK;
				break;
			}
		}
		if (soap->mode & SOAP_C_NOIOB)
			while (soap_element_end_in(soap, tag) == SOAP_SYNTAX_ERROR)
			{	soap->peeked = 1;
				soap_ignore_element(soap);
			}
		else if (soap_element_end_in(soap, tag))
		{	if (soap->error == SOAP_SYNTAX_ERROR)
				soap->error = SOAP_IOB;
			return NULL;
		}
	}
	else
	{	a = (float (*))soap_id_forward(soap, soap->href, (void*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_deepf1_gsoap_Array4Offloat, sizeof(float[4]), NULL, NULL, NULL, NULL), 0, SOAP_TYPE_deepf1_gsoap_Array4Offloat, SOAP_TYPE_deepf1_gsoap_Array4Offloat, sizeof(float[4]), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return (float *)a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_Array4Offloat(struct soap *soap, float const a[4], const char *tag, const char *type)
{
	if (soap_out_Array4Offloat(soap, tag ? tag : "SOAP-ENC:Array", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 float * SOAP_FMAC4 soap_get_Array4Offloat(struct soap *soap, float a[4], const char *tag, const char *type)
{	float (*p);
	if ((p = soap_in_Array4Offloat(soap, tag, a, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_Array3Offloat(struct soap *soap, float a[3])
{
	int i;
	(void)soap; /* appease -Wall -Werror */
	for (i = 0; i < 3; i++)
		soap_default_float(soap, a+i);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_Array3Offloat(struct soap *soap, float const a[3])
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_Array3Offloat(struct soap *soap, const char *tag, int id, float const a[3], const char *type)
{
	size_t i;
	(void)type;
	soap_array_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_deepf1_gsoap_Array3Offloat), "xsd:float[3]", 0);
	for (i = 0; i < 3; i++)
	{
		if (soap_out_float(soap, "item", -1, a+i, ""))
			return soap->error;
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 float * SOAP_FMAC4 soap_in_Array3Offloat(struct soap *soap, const char *tag, float a[3], const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	if (soap_match_array(soap, type))
	{	soap->error = SOAP_TYPE;
		return NULL;
	}
	a = (float (*))soap_id_enter(soap, soap->id, a, SOAP_TYPE_deepf1_gsoap_Array3Offloat, sizeof(float[3]), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_Array3Offloat(soap, a);
	if (soap->body && *soap->href != '#')
	{	int i;
		for (i = 0; i < 3; i++)
		{	soap_peek_element(soap);
			if (soap->position)
			{	i = soap->positions[0];
				if (i < 0 || i >= 3)
				{	soap->error = SOAP_IOB;
					return NULL;
				}
			}
			if (!soap_in_float(soap, NULL, a+i, "xsd:float"))
			{	if (soap->error != SOAP_NO_TAG)
					return NULL;
				soap->error = SOAP_OK;
				break;
			}
		}
		if (soap->mode & SOAP_C_NOIOB)
			while (soap_element_end_in(soap, tag) == SOAP_SYNTAX_ERROR)
			{	soap->peeked = 1;
				soap_ignore_element(soap);
			}
		else if (soap_element_end_in(soap, tag))
		{	if (soap->error == SOAP_SYNTAX_ERROR)
				soap->error = SOAP_IOB;
			return NULL;
		}
	}
	else
	{	a = (float (*))soap_id_forward(soap, soap->href, (void*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_deepf1_gsoap_Array3Offloat, sizeof(float[3]), NULL, NULL, NULL, NULL), 0, SOAP_TYPE_deepf1_gsoap_Array3Offloat, SOAP_TYPE_deepf1_gsoap_Array3Offloat, sizeof(float[3]), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return (float *)a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_Array3Offloat(struct soap *soap, float const a[3], const char *tag, const char *type)
{
	if (soap_out_Array3Offloat(soap, tag ? tag : "SOAP-ENC:Array", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 float * SOAP_FMAC4 soap_get_Array3Offloat(struct soap *soap, float a[3], const char *tag, const char *type)
{	float (*p);
	if ((p = soap_in_Array3Offloat(soap, tag, a, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

} // namespace deepf1_gsoap


#if defined(__BORLANDC__)
#pragma option pop
#pragma option pop
#endif

/* End of deepf1_gsoapC.cpp */
